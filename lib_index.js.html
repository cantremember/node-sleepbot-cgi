<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cantremember/node-sleepbot-cgi - Source: lib/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<a href="https://github.com/cantremember/node-sleepbot-cgi"><img
    style="position: fixed; top: 0; right: 0; border: 0;"
    src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67"
    alt="Fork me on GitHub"
    data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"
></a>

<div id="main">
    <h1 class="page-title">Source: lib/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

// execute our temporary polyfills
require('./polyfill');

// jshint -W079
var Promise = require('bluebird');
// jshint +W079
var path = require('path');
var fs = require('fs');
var willReadFile = Promise.promisify(fs.readFile);
var willStat = Promise.promisify(fs.stat);
var glob = Promise.promisify(require('glob'));
var csv = require('csv');

var FS_READ_OPTIONS = Object.freeze({
    encoding: 'utf8'
});
var CSV_PARSE_OPTIONS = Object.freeze({
    delimiter: '\t', // TSV
    trim: true,
    comment: '#',
    skip_empty_lines: true,
    // a magic option that `csv-parse` injects;
    //   without it, we can't Object#freeze
    //   "TypeError: Invalid non-string/buffer chunk"
    objectMode: true });
var forgetMemoize = [];

/**
 * #### A Library of Functions and Singletons
 *
 * &amp;nbsp;
 *
 * @namespace lib
 */
var theLib = Object.defineProperties({
    /**
     * @memberof lib
     * @see config
     */
    config: require('./config'),

    /**
     * @memberof lib
     * @param {Function} will a Function executing a Promise whose result will be memoized
     * @returns {Function} a Function returning a Promise which memomizes the result of `will`
     */
    willMemoize: function willMemoize(will) {
        var result = undefined;
        forgetMemoize.push(function () {
            result = undefined;
        });

        // leave as a Function;
        //   the scope of `this` &amp; `arguments` are bound to where
        //   the `() => { }` is defined, vs. decoupled, as we need it to be
        return function () {
            if (result !== undefined) {
                return Promise.resolve(result);
            }

            var self = this;
            var args = arguments;
            return Promise.resolve().then(function () {
                // from within an established Promise
                return will.apply(self, args);
            }).then(function (_result) {
                if (theLib.config.get('caching')) {
                    // cache
                    result = _result;
                }
                return _result;
            });
        };
    },

    /**
     * Forgets any results cached by {@link lib.willMemoize}
     *
     * @memberof lib
     */
    forget: function forget() {
        // FIXME:  TypeError: Property '@@iterator' of object"
        //   for (let f of forgetMemoize) {
        for (var i = 0; i &lt; forgetMemoize.length; ++i) {
            forgetMemoize[i]();
        }
    },

    /**
     * This method is used within the Promise chain in [Express](https://npmjs.com/package/express) handlers.
     *
     * The callback passed by Express to a handler should only be called
     * - to halt the chain due to an unrecoverable Error in the handler, or
     * - to otherwise continue down the middleware chain past the handler
     *
     * Express does *not* expect a callback after an `express.response#end`;
     * that operation should terminate the chain.
     *
     * However, Promises are used for asynchronous executional flow,
     * and for Test Suite purposes, it's important to know if a handler has resolved or rejected.
     * Re-throwing the Error makes this possible.
     *
     * @memberof lib
     * @param {Function} cb a [CPS](https://en.wikipedia.org/wiki/Continuation-passing_style) callback Function
     * @returns {Function} a callback Function which takes an Error and
     *   - invokes `cb` with the Error
     *   - throws the Error, assumably to reject by the Promise chain in which the Error was caught
     */
    callbackAndThrowError: function callbackAndThrowError(cb) {
        return function (err) {
            if (typeof cb === 'function') {
                cb(err);
            }
            throw err;
        };
    },

    /**
     * @memberof lib
     * @param {Array&lt;Object>} array an Array
     * @returns {Object} a random value from `array`
     */
    chooseAny: function chooseAny(array) {
        if (!Array.isArray(array)) {
            return undefined;
        }
        var choice = Math.floor(Math.random() * array.length);
        return array[choice];
    },

    /**
     * @memberof lib
     * @param {String} route a root-relative path
     * @returns {String} an absolute URL relative to `baseURL` from {@link config}
     */
    baseURL: function baseURL() {
        var route = arguments[0] === undefined ? '' : arguments[0];

        return this.config.get('baseURL') + route;
    },

    /**
     * @example
     * assert.deepEqual(
     *     lib.columnToIndexMap('zero one two'),
     *     { zero: 0, one: 1, two: 2 }
     * )
     *
     * @memberof lib
     * @param {String} spaceDelimited a space-delimited String of column names
     * @returns {Object&lt;Integer>} a property Object mapping each column name to its column index
     */
    columnToIndexMap: function columnToIndexMap(spaceDelimited) {
        return (spaceDelimited || '').split(/\s/).reduce(function (total, column, index) {
            if (column !== '') {
                total[column] = index;
            }
            return total;
        }, {});
    },

    /**
     * @example
     * assert.deepEqual(
     *     lib.dataColumnMap([ 'cero', 'uno', 'dos' ], { zero: 0, one: 1, two: 2 }),
     *     { zero: 'cero', one: 'uno', two: 'dos' }
     * )
     *
     * @memberof lib
     * @param {Array&lt;Object>} row an Array of values
     * @param {Object&lt;Integer>} columnToIndex the results of {@link lib.columnToIndexMap}
     * @returns {Object&lt;Object>} a property Object mapping each column name to its `row` value
     */
    dataColumnMap: function dataColumnMap(row, columnToIndex) {
        return Object.keys(columnToIndex || {}).reduce(function (map, key) {
            map[key] = row[columnToIndex[key]];
            return map;
        }, {});
    },

    /**
     * #### A Library of Functions relating to `wwwRoot` from {@link config}
     *
     * &amp;nbsp;
     *
     * @namespace lib.wwwRoot
     */
    wwwRoot: {
        /**
         * @see lib.dataColumnMap
         * @memberof lib.wwwRoot
         * @param {String} relativePath a path relative to {@link lib.wwwRoot}
         * @param {Object&lt;Integer>} [options] options for a [csv](https://www.npmjs.com/package/csv) parser
         * @returns {Promise&lt;Array>} a Promise resolving the rows of the TSV file at `relativePath`
         */
        willLoadTSV: function willLoadTSV(relativePath) {
            var options = arguments[1] === undefined ? CSV_PARSE_OPTIONS : arguments[1];

            return new Promise(function (resolve, reject) {
                try {
                    (function () {
                        var filepath = path.join(theLib.config.get('wwwRoot'), relativePath);
                        var reader = fs.createReadStream(filepath, FS_READ_OPTIONS);
                        var parser = csv.parse(options);
                        var buffer = [];

                        reader.on('error', reject);
                        parser.on('error', reject);
                        parser.on('readable', function () {
                            var data = undefined;
                            while (data = parser.read()) {
                                buffer.push(data);
                            }
                        });
                        parser.on('end', function () {
                            // do not release Zalgo
                            setImmediate(function () {
                                resolve(buffer);
                            });
                        });
                        reader.pipe(parser);
                    })();
                } catch (err) {
                    reject(err);
                }
            }).then(function (result) {
                // drop the first line -- the headers
                return result.slice(1);
            });
        },

        /**
         * @memberof lib.wwwRoot
         * @param {String} relativePath a path relative to {@link lib.wwwRoot}
         * @returns {Promise&lt;String>} a Promise resolving the contents of the file at `relativePath`
         */
        willLoadFile: function willLoadFile(relativePath) {
            return this.willDetectFile(relativePath).then(function (exists) {
                if (!exists) {
                    return '';
                }

                var filepath = path.join(theLib.config.get('wwwRoot'), relativePath);
                return willReadFile(filepath, FS_READ_OPTIONS);
            });
        },

        /**
         * @memberof lib.wwwRoot
         * @param {String} fileglob a path-and-glob-pattern relative to {@link lib.wwwRoot}
         * @returns {Promise&lt;Array>} a Promise resolving the filenames matching `fileglob`
         */
        willGetFilenames: function willGetFilenames(fileglob) {
            return glob(path.join(theLib.config.get('wwwRoot'), fileglob)).then(function (files) {
                // just the filename, please
                return files.map(function (file) {
                    return path.basename(file);
                });
            });
        },

        /**
         * @memberof lib.wwwRoot
         * @param {String} relativePath a path relative to {@link lib.wwwRoot}
         * @returns {Promise&lt;Array>} a Promise resolving true if a file exists at `relativePath`
         */
        willDetectFile: function willDetectFile(relativePath) {
            return willStat(path.join(theLib.config.get('wwwRoot'), relativePath)).then(function (stat) {
                return stat.isFile();
            })['catch'](function (err) {
                // traverse the cause chain, eg. `OperationalError`
                var cause = undefined;
                while (cause = err.cause) {
                    err = cause;
                }

                if (err.code === 'ENOENT') {
                    return false;
                }
                throw err;
            });
        } } }, {
    app: {

        /**
         * @memberof lib
         * @see app
         */

        get: function () {
            // avoid circular dependency hell with a getter
            return require('./app');
        },
        configurable: true,
        enumerable: true
    }
});

module.exports = theLib;
//# sourceMappingURL=../../sourcemaps/lib/index.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="app.html">app</a></li><li><a href="config.html">config</a></li><li><a href="lib.html">lib</a></li><li><a href="lib.wwwRoot.html">wwwRoot</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Array_includes">Array_includes</a></li><li><a href="global.html#String_includes">String_includes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta1</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
