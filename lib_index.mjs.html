<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cantremember/node-sleepbot-cgi - Source: lib/index.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<a href="https://github.com/cantremember/node-sleepbot-cgi"><img
    style="position: fixed; top: 0; right: 0; border: 0;"
    src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67"
    alt="Fork me on GitHub"
    data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"
></a>

<div id="main">
    <h1 class="page-title">Source: lib/index.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Promise from 'bluebird';
import _ from 'lodash';

import theConfig from './config';

const forgetMemoize = [];


/**
 * #### A Library of Functions and Singletons
 *
 * &amp;nbsp;
 *
 * @namespace lib
 */
export default {
  /**
   * @memberof lib
   * @see config
   */
  config: theConfig,

  /**
   * @memberof lib
   * @returns {String} the primary SEB server
   */
  get sebServerPrimary() {
    const servers = this.config.get('sebServers');

    return servers.reduce((prior, current) => {
      return current.primary ? /* istanbul ignore next */ current : prior;
    });
  },


  /**
   * @memberof lib
   * @param {Function} will a Function executing a Promise whose result will be memoized
   * @returns {Function&lt;Promise>} a Function returning a Promise which memomizes the result of `will`
   */
  willMemoize(will) {
    const { config } = this;

    // captured in scope
    let result;
    forgetMemoize.push(() => {
      result = undefined;
    });

    // leave as a Function;
    //   the scope of `this` &amp; `arguments` are bound to where
    //   the `() => { }` is defined, vs. decoupled, as we need it to be
    return async function(...args) {
      if (result !== undefined) {
        return Promise.resolve(result);
      }

      const self = this; // eslint-disable-line no-invalid-this
      const _result = await Promise.try(() => {
        // from within an established Promise
        return will.apply(self, args);
      });

      if (config.get('caching')) {
        // cache
        result = _result;
      }
      return _result;
    };
  },

  /**
   * Forgets any results cached by {@link lib.willMemoize}
   *
   * @memberof lib
   */
  forget() {
    // FIXME:  TypeError: Property '@@iterator' of object"
    //   for (let f of forgetMemoize) {
    for (let i = 0; i &lt; forgetMemoize.length; ++i) {
      forgetMemoize[i]();
    }
  },

  /**
   * @memberof lib
   * @param {Array&lt;Object>} array an Array
   * @returns {Object} a random value from `array`
   */
  chooseAny(array) {
    if (! Array.isArray(array)) {
      return undefined;
    }
    const choice = Math.floor(Math.random() * array.length);
    return array[choice];
  },

  /**
   * @memberof lib
   * @param {String} route a root-relative path
   * @returns {String} an absolute URL relative to `baseURL` from {@link config}
   */
  baseURL(/* istanbul ignore next */ route = '') {
    return this.config.get('baseURL') + route;
  },


  /**
   * @example
   * assert.deepEqual(
   *     lib.columnToIndexMap('zero one two'),
   *     { zero: 0, one: 1, two: 2 }
   * )
   *
   * @memberof lib
   * @param {String} spaceDelimited a space-delimited String of column names
   * @returns {Object&lt;Integer>} a property Object mapping each column name to its column index
   */
  columnToIndexMap(spaceDelimited) {
    return (spaceDelimited || '').split(/\s/).reduce((total, column, index) => {
      if (column !== '') {
        total[column] = index;
      }
      return total;
    }, {});
  },

  /**
   * @example
   * assert.deepEqual(
   *     lib.dataColumnMap([ 'cero', 'uno', 'dos' ], { zero: 0, one: 1, two: 2 }),
   *     { zero: 'cero', one: 'uno', two: 'dos' }
   * )
   *
   * @memberof lib
   * @param {Array&lt;Object>} row an Array of values
   * @param {Object&lt;Integer>} columnToIndex the results of {@link lib.columnToIndexMap}
   * @returns {Object&lt;Object>} a property Object mapping each column name to its `row` value
   */
  dataColumnMap(row, columnToIndex) {
    return Object.keys(columnToIndex || {}).reduce((map, key) => {
      map[key] = row[columnToIndex[key]];
      return map;
    }, {});
  },


  /**
   * @memberof lib
   * @param {express.Response} res
   * @param {String} filename the template filename, relative to `viewsRoot` from {@link config}
   * @param {Object} context a render context Object
   * @returns {Promise&lt;String>} a Promise resolving the results of `ejs` rendering
   */
  async willRenderView(res, filename, context) { // eslint-disable-line require-await
    // well, *this* is just dandy
    //   #render from `node-http-mock#createResponse` doesn't support a callback
    //   and the Object returned doesn't have a Prototype, so it can't be monkey-patched
    //   we must DETECT THIS CONDITION the hard way
    if (res.render.length > 2) {
      // a basic Promise wrapper around express.Response#render
      return new Promise((resolve, reject) => {
        res.render(filename, context, (err, rendered) => {
          if (err) {
            reject(err);
          }
          else {
            resolve(rendered);
          }
        });
      });
    }

    // this has better be the results of a `createResponse`
    if (! _.isFunction(res._getData)) {
      throw new Error('not applying monkey-patch to Response#render in `node-mocks-http`');
    }

    // there is no actual "rendering" going on, and the context may be omitted entirely
    //   so we'll just echo back the filename
    return new Promise((resolve, reject) => {
      try {
        res.render(filename, context);
        resolve(res._getRenderView());
      }
      catch (err) {
        reject(err);
      }
    });
  },
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="app.html">app</a></li><li><a href="config.html">config</a></li><li><a href="lib.html">lib</a></li><li><a href="wwwRoot.html">wwwRoot</a></li></ul><h3>Global</h3><ul><li><a href="global.html#taskDoc">taskDoc</a></li><li><a href="global.html#taskLint">taskLint</a></li><li><a href="global.html#willTryServers">willTryServers</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
